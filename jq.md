## Command Breakdown

Let's break down this command:

- **kubectl get deployment -o json**: This part of the command retrieves the JSON data for deployments using `kubectl`.

- **jq -r '.items[] | .metadata.labels | to_entries | map(.key + "_" + .value) | join("-") as $filename | . as $deployment | $filename, $deployment | @sh "echo \(.[$filename]) > \(.[$deployment] | tojson)"'**: This `jq` command processes the JSON data as follows:

    - `.items[]`: Iterates over each deployment.
    - `.metadata.labels | to_entries`: Converts the labels object into an array of key-value pairs.
    - `map(.key + "_" + .value)`: Maps each key-value pair to a string in the format "key_value".
    - `join("-") as $filename`: Joins the key-value strings with hyphens to create the filename.
    - `. as $deployment`: Saves the current deployment object.
    - `$filename, $deployment`: Outputs the filename and the deployment object together.
    - `@sh "echo \(.[$filename]) > \(.[$deployment] | tojson)"`: Uses `@sh` to execute a shell command that echoes the deployment JSON to a file with the specified filename.

- **xargs -I{} bash -c {}**: This part of the command executes each shell command generated by `jq`, which effectively creates individual JSON files based on the deployment labels.

This command will split the deployments into separate JSON files, with filenames based on the labels of each deployment.

